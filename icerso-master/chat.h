// **********************************************************************
//
// Copyright (c) 2003-2017 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `chat.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __chat_h__
#define __chat_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace Chat
{

class GroupServer;
class GroupServerPrx;
class GroupServerManager;
class GroupServerManagerPrx;
class User;
class UserPrx;
class ChatServer;
class ChatServerPrx;

}

namespace Chat
{

class NameDoesNotExist : public ::Ice::UserExceptionHelper<NameDoesNotExist, ::Ice::UserException>
{
public:

    virtual ~NameDoesNotExist();

    NameDoesNotExist(const NameDoesNotExist&) = default;

    NameDoesNotExist() = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

static NameDoesNotExist _iceS_NameDoesNotExist_init;

class NameAlreadyExists : public ::Ice::UserExceptionHelper<NameAlreadyExists, ::Ice::UserException>
{
public:

    virtual ~NameAlreadyExists();

    NameAlreadyExists(const NameAlreadyExists&) = default;

    NameAlreadyExists() = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

class ServerAlreadyRegistered : public ::Ice::UserExceptionHelper<ServerAlreadyRegistered, ::Ice::UserException>
{
public:

    virtual ~ServerAlreadyRegistered();

    ServerAlreadyRegistered(const ServerAlreadyRegistered&) = default;

    ServerAlreadyRegistered() = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

class ServerDoesNotExist : public ::Ice::UserExceptionHelper<ServerDoesNotExist, ::Ice::UserException>
{
public:

    virtual ~ServerDoesNotExist();

    ServerDoesNotExist(const ServerDoesNotExist&) = default;

    ServerDoesNotExist() = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

class UserAlreadyRegistered : public ::Ice::UserExceptionHelper<UserAlreadyRegistered, ::Ice::UserException>
{
public:

    virtual ~UserAlreadyRegistered();

    UserAlreadyRegistered(const UserAlreadyRegistered&) = default;

    UserAlreadyRegistered() = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

class UserDoesNotExist : public ::Ice::UserExceptionHelper<UserDoesNotExist, ::Ice::UserException>
{
public:

    virtual ~UserDoesNotExist();

    UserDoesNotExist(const UserDoesNotExist&) = default;

    UserDoesNotExist() = default;

    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    static const ::std::string& ice_staticId();
};

using Groups = ::std::vector<::std::shared_ptr<::Chat::GroupServerPrx>>;

using Users = ::std::vector<::std::shared_ptr<::Chat::UserPrx>>;

}

namespace Chat
{

class ChatServer : public virtual ::Ice::Object
{
public:

    using ProxyType = ChatServerPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual void LogIn(::std::shared_ptr<::Chat::UserPrx>, const ::Ice::Current&) = 0;
    bool _iceD_LogIn(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::shared_ptr<::Chat::UserPrx> getUserByName(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_getUserByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Groups GroupList(const ::Ice::Current&) = 0;
    bool _iceD_GroupList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::shared_ptr<::Chat::GroupServerPrx> getGroupServerByName(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_getGroupServerByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void CreateGroup(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_CreateGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void DeleteGroup(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_DeleteGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void registerServer(::std::shared_ptr<::Chat::GroupServerManagerPrx>, const ::Ice::Current&) = 0;
    bool _iceD_registerServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unregisterServer(::std::shared_ptr<::Chat::GroupServerManagerPrx>, const ::Ice::Current&) = 0;
    bool _iceD_unregisterServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void LogOut(::std::shared_ptr<::Chat::UserPrx>, const ::Ice::Current&) = 0;
    bool _iceD_LogOut(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class GroupServer : public virtual ::Ice::Object
{
public:

    using ProxyType = GroupServerPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual void join(::std::shared_ptr<::Chat::UserPrx>, const ::Ice::Current&) = 0;
    bool _iceD_join(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void Leave(::std::shared_ptr<::Chat::UserPrx>, const ::Ice::Current&) = 0;
    bool _iceD_Leave(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SendMessage(::std::string, ::std::shared_ptr<::Chat::UserPrx>, ::std::shared_ptr<::Chat::GroupServerPrx>, const ::Ice::Current&) = 0;
    bool _iceD_SendMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Users UserList(const ::Ice::Current&) = 0;
    bool _iceD_UserList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string Name(const ::Ice::Current&) = 0;
    bool _iceD_Name(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class GroupServerManager : public virtual ::Ice::Object
{
public:

    using ProxyType = GroupServerManagerPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<::Chat::GroupServerPrx> CreateGroup(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_CreateGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Groups ListGroups(const ::Ice::Current&) = 0;
    bool _iceD_ListGroups(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void DeleteGroup(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_DeleteGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::shared_ptr<::Chat::GroupServerPrx> getGroupServerByName(::std::string, const ::Ice::Current&) = 0;
    bool _iceD_getGroupServerByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

class User : public virtual ::Ice::Object
{
public:

    using ProxyType = UserPrx;

    virtual bool ice_isA(::std::string, const ::Ice::Current&) const override;
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current&) const override;
    virtual ::std::string ice_id(const ::Ice::Current&) const override;

    static const ::std::string& ice_staticId();

    virtual ::std::string getName(const ::Ice::Current&) = 0;
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void receiveText(::std::string, ::std::shared_ptr<::Chat::UserPrx>, ::std::string, const ::Ice::Current&) = 0;
    bool _iceD_receiveText(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void receivePrivateText(::std::string, ::std::shared_ptr<::Chat::UserPrx>, const ::Ice::Current&) = 0;
    bool _iceD_receivePrivateText(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
};

}

namespace Chat
{

class ChatServerPrx : public virtual ::Ice::Proxy<ChatServerPrx, ::Ice::ObjectPrx>
{
public:

    void LogIn(const ::std::shared_ptr<::Chat::UserPrx>& iceP_callback, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::ChatServerPrx::_iceI_LogIn, iceP_callback, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto LogInAsync(const ::std::shared_ptr<::Chat::UserPrx>& iceP_callback, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::ChatServerPrx::_iceI_LogIn, iceP_callback, context);
    }

    ::std::function<void()>
    LogInAsync(const ::std::shared_ptr<::Chat::UserPrx>& iceP_callback,
               ::std::function<void()> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::ChatServerPrx::_iceI_LogIn, iceP_callback, context);
    }

    void _iceI_LogIn(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Chat::UserPrx>&, const ::Ice::Context&);

    ::std::shared_ptr<::Chat::UserPrx> getUserByName(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Chat::UserPrx>>(true, this, &Chat::ChatServerPrx::_iceI_getUserByName, iceP_name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getUserByNameAsync(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Chat::UserPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Chat::UserPrx>, P>(false, this, &Chat::ChatServerPrx::_iceI_getUserByName, iceP_name, context);
    }

    ::std::function<void()>
    getUserByNameAsync(const ::std::string& iceP_name,
                       ::std::function<void(::std::shared_ptr<::Chat::UserPrx>)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Chat::UserPrx>>(response, ex, sent, this, &Chat::ChatServerPrx::_iceI_getUserByName, iceP_name, context);
    }

    void _iceI_getUserByName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Chat::UserPrx>>>&, const ::std::string&, const ::Ice::Context&);

    ::Chat::Groups GroupList(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Chat::Groups>(true, this, &Chat::ChatServerPrx::_iceI_GroupList, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GroupListAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Chat::Groups>>().get_future())
    {
        return _makePromiseOutgoing<::Chat::Groups, P>(false, this, &Chat::ChatServerPrx::_iceI_GroupList, context);
    }

    ::std::function<void()>
    GroupListAsync(::std::function<void(::Chat::Groups)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Chat::Groups>(response, ex, sent, this, &Chat::ChatServerPrx::_iceI_GroupList, context);
    }

    void _iceI_GroupList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Chat::Groups>>&, const ::Ice::Context&);

    ::std::shared_ptr<::Chat::GroupServerPrx> getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Chat::GroupServerPrx>>(true, this, &Chat::ChatServerPrx::_iceI_getGroupServerByName, iceP_name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getGroupServerByNameAsync(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Chat::GroupServerPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Chat::GroupServerPrx>, P>(false, this, &Chat::ChatServerPrx::_iceI_getGroupServerByName, iceP_name, context);
    }

    ::std::function<void()>
    getGroupServerByNameAsync(const ::std::string& iceP_name,
                              ::std::function<void(::std::shared_ptr<::Chat::GroupServerPrx>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Chat::GroupServerPrx>>(response, ex, sent, this, &Chat::ChatServerPrx::_iceI_getGroupServerByName, iceP_name, context);
    }

    void _iceI_getGroupServerByName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Chat::GroupServerPrx>>>&, const ::std::string&, const ::Ice::Context&);

    void CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::ChatServerPrx::_iceI_CreateGroup, iceP_name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto CreateGroupAsync(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::ChatServerPrx::_iceI_CreateGroup, iceP_name, context);
    }

    ::std::function<void()>
    CreateGroupAsync(const ::std::string& iceP_name,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::ChatServerPrx::_iceI_CreateGroup, iceP_name, context);
    }

    void _iceI_CreateGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);

    void DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::ChatServerPrx::_iceI_DeleteGroup, iceP_name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto DeleteGroupAsync(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::ChatServerPrx::_iceI_DeleteGroup, iceP_name, context);
    }

    ::std::function<void()>
    DeleteGroupAsync(const ::std::string& iceP_name,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::ChatServerPrx::_iceI_DeleteGroup, iceP_name, context);
    }

    void _iceI_DeleteGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);

    void registerServer(const ::std::shared_ptr<::Chat::GroupServerManagerPrx>& iceP_serverManager, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::ChatServerPrx::_iceI_registerServer, iceP_serverManager, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerServerAsync(const ::std::shared_ptr<::Chat::GroupServerManagerPrx>& iceP_serverManager, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::ChatServerPrx::_iceI_registerServer, iceP_serverManager, context);
    }

    ::std::function<void()>
    registerServerAsync(const ::std::shared_ptr<::Chat::GroupServerManagerPrx>& iceP_serverManager,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::ChatServerPrx::_iceI_registerServer, iceP_serverManager, context);
    }

    void _iceI_registerServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Chat::GroupServerManagerPrx>&, const ::Ice::Context&);

    void unregisterServer(const ::std::shared_ptr<::Chat::GroupServerManagerPrx>& iceP_serverManager, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::ChatServerPrx::_iceI_unregisterServer, iceP_serverManager, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unregisterServerAsync(const ::std::shared_ptr<::Chat::GroupServerManagerPrx>& iceP_serverManager, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::ChatServerPrx::_iceI_unregisterServer, iceP_serverManager, context);
    }

    ::std::function<void()>
    unregisterServerAsync(const ::std::shared_ptr<::Chat::GroupServerManagerPrx>& iceP_serverManager,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::ChatServerPrx::_iceI_unregisterServer, iceP_serverManager, context);
    }

    void _iceI_unregisterServer(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Chat::GroupServerManagerPrx>&, const ::Ice::Context&);

    void LogOut(const ::std::shared_ptr<::Chat::UserPrx>& iceP_callback, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::ChatServerPrx::_iceI_LogOut, iceP_callback, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto LogOutAsync(const ::std::shared_ptr<::Chat::UserPrx>& iceP_callback, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::ChatServerPrx::_iceI_LogOut, iceP_callback, context);
    }

    ::std::function<void()>
    LogOutAsync(const ::std::shared_ptr<::Chat::UserPrx>& iceP_callback,
                ::std::function<void()> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::ChatServerPrx::_iceI_LogOut, iceP_callback, context);
    }

    void _iceI_LogOut(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Chat::UserPrx>&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    ChatServerPrx() = default;
    friend ::std::shared_ptr<ChatServerPrx> IceInternal::createProxy<ChatServerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class GroupServerPrx : public virtual ::Ice::Proxy<GroupServerPrx, ::Ice::ObjectPrx>
{
public:

    void join(const ::std::shared_ptr<::Chat::UserPrx>& iceP_who, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::GroupServerPrx::_iceI_join, iceP_who, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto joinAsync(const ::std::shared_ptr<::Chat::UserPrx>& iceP_who, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::GroupServerPrx::_iceI_join, iceP_who, context);
    }

    ::std::function<void()>
    joinAsync(const ::std::shared_ptr<::Chat::UserPrx>& iceP_who,
              ::std::function<void()> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::GroupServerPrx::_iceI_join, iceP_who, context);
    }

    void _iceI_join(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Chat::UserPrx>&, const ::Ice::Context&);

    void Leave(const ::std::shared_ptr<::Chat::UserPrx>& iceP_who, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::GroupServerPrx::_iceI_Leave, iceP_who, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto LeaveAsync(const ::std::shared_ptr<::Chat::UserPrx>& iceP_who, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::GroupServerPrx::_iceI_Leave, iceP_who, context);
    }

    ::std::function<void()>
    LeaveAsync(const ::std::shared_ptr<::Chat::UserPrx>& iceP_who,
               ::std::function<void()> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::GroupServerPrx::_iceI_Leave, iceP_who, context);
    }

    void _iceI_Leave(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<::Chat::UserPrx>&, const ::Ice::Context&);

    void SendMessage(const ::std::string& iceP_message, const ::std::shared_ptr<::Chat::UserPrx>& iceP_sender, const ::std::shared_ptr<::Chat::GroupServerPrx>& iceP_gs, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::GroupServerPrx::_iceI_SendMessage, iceP_message, iceP_sender, iceP_gs, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendMessageAsync(const ::std::string& iceP_message, const ::std::shared_ptr<::Chat::UserPrx>& iceP_sender, const ::std::shared_ptr<::Chat::GroupServerPrx>& iceP_gs, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::GroupServerPrx::_iceI_SendMessage, iceP_message, iceP_sender, iceP_gs, context);
    }

    ::std::function<void()>
    SendMessageAsync(const ::std::string& iceP_message, const ::std::shared_ptr<::Chat::UserPrx>& iceP_sender, const ::std::shared_ptr<::Chat::GroupServerPrx>& iceP_gs,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::GroupServerPrx::_iceI_SendMessage, iceP_message, iceP_sender, iceP_gs, context);
    }

    void _iceI_SendMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::shared_ptr<::Chat::UserPrx>&, const ::std::shared_ptr<::Chat::GroupServerPrx>&, const ::Ice::Context&);

    ::Chat::Users UserList(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Chat::Users>(true, this, &Chat::GroupServerPrx::_iceI_UserList, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UserListAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Chat::Users>>().get_future())
    {
        return _makePromiseOutgoing<::Chat::Users, P>(false, this, &Chat::GroupServerPrx::_iceI_UserList, context);
    }

    ::std::function<void()>
    UserListAsync(::std::function<void(::Chat::Users)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Chat::Users>(response, ex, sent, this, &Chat::GroupServerPrx::_iceI_UserList, context);
    }

    void _iceI_UserList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Chat::Users>>&, const ::Ice::Context&);

    ::std::string Name(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &Chat::GroupServerPrx::_iceI_Name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto NameAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &Chat::GroupServerPrx::_iceI_Name, context);
    }

    ::std::function<void()>
    NameAsync(::std::function<void(::std::string)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(response, ex, sent, this, &Chat::GroupServerPrx::_iceI_Name, context);
    }

    void _iceI_Name(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    GroupServerPrx() = default;
    friend ::std::shared_ptr<GroupServerPrx> IceInternal::createProxy<GroupServerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class GroupServerManagerPrx : public virtual ::Ice::Proxy<GroupServerManagerPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<::Chat::GroupServerPrx> CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Chat::GroupServerPrx>>(true, this, &Chat::GroupServerManagerPrx::_iceI_CreateGroup, iceP_name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto CreateGroupAsync(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Chat::GroupServerPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Chat::GroupServerPrx>, P>(false, this, &Chat::GroupServerManagerPrx::_iceI_CreateGroup, iceP_name, context);
    }

    ::std::function<void()>
    CreateGroupAsync(const ::std::string& iceP_name,
                     ::std::function<void(::std::shared_ptr<::Chat::GroupServerPrx>)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Chat::GroupServerPrx>>(response, ex, sent, this, &Chat::GroupServerManagerPrx::_iceI_CreateGroup, iceP_name, context);
    }

    void _iceI_CreateGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Chat::GroupServerPrx>>>&, const ::std::string&, const ::Ice::Context&);

    ::Chat::Groups ListGroups(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::Chat::Groups>(true, this, &Chat::GroupServerManagerPrx::_iceI_ListGroups, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ListGroupsAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::Chat::Groups>>().get_future())
    {
        return _makePromiseOutgoing<::Chat::Groups, P>(false, this, &Chat::GroupServerManagerPrx::_iceI_ListGroups, context);
    }

    ::std::function<void()>
    ListGroupsAsync(::std::function<void(::Chat::Groups)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::Chat::Groups>(response, ex, sent, this, &Chat::GroupServerManagerPrx::_iceI_ListGroups, context);
    }

    void _iceI_ListGroups(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::Chat::Groups>>&, const ::Ice::Context&);

    void DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::GroupServerManagerPrx::_iceI_DeleteGroup, iceP_name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto DeleteGroupAsync(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::GroupServerManagerPrx::_iceI_DeleteGroup, iceP_name, context);
    }

    ::std::function<void()>
    DeleteGroupAsync(const ::std::string& iceP_name,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::GroupServerManagerPrx::_iceI_DeleteGroup, iceP_name, context);
    }

    void _iceI_DeleteGroup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);

    ::std::shared_ptr<::Chat::GroupServerPrx> getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Chat::GroupServerPrx>>(true, this, &Chat::GroupServerManagerPrx::_iceI_getGroupServerByName, iceP_name, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getGroupServerByNameAsync(const ::std::string& iceP_name, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::Chat::GroupServerPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::Chat::GroupServerPrx>, P>(false, this, &Chat::GroupServerManagerPrx::_iceI_getGroupServerByName, iceP_name, context);
    }

    ::std::function<void()>
    getGroupServerByNameAsync(const ::std::string& iceP_name,
                              ::std::function<void(::std::shared_ptr<::Chat::GroupServerPrx>)> response,
                              ::std::function<void(::std::exception_ptr)> ex = nullptr,
                              ::std::function<void(bool)> sent = nullptr,
                              const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::Chat::GroupServerPrx>>(response, ex, sent, this, &Chat::GroupServerManagerPrx::_iceI_getGroupServerByName, iceP_name, context);
    }

    void _iceI_getGroupServerByName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::Chat::GroupServerPrx>>>&, const ::std::string&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    GroupServerManagerPrx() = default;
    friend ::std::shared_ptr<GroupServerManagerPrx> IceInternal::createProxy<GroupServerManagerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

class UserPrx : public virtual ::Ice::Proxy<UserPrx, ::Ice::ObjectPrx>
{
public:

    ::std::string getName(const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &Chat::UserPrx::_iceI_getName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNameAsync(const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &Chat::UserPrx::_iceI_getName, context);
    }

    ::std::function<void()>
    getNameAsync(::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(response, ex, sent, this, &Chat::UserPrx::_iceI_getName, context);
    }

    void _iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);

    void receiveText(const ::std::string& iceP_msg, const ::std::shared_ptr<::Chat::UserPrx>& iceP_sender, const ::std::string& iceP_serverName, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::UserPrx::_iceI_receiveText, iceP_msg, iceP_sender, iceP_serverName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto receiveTextAsync(const ::std::string& iceP_msg, const ::std::shared_ptr<::Chat::UserPrx>& iceP_sender, const ::std::string& iceP_serverName, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::UserPrx::_iceI_receiveText, iceP_msg, iceP_sender, iceP_serverName, context);
    }

    ::std::function<void()>
    receiveTextAsync(const ::std::string& iceP_msg, const ::std::shared_ptr<::Chat::UserPrx>& iceP_sender, const ::std::string& iceP_serverName,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::UserPrx::_iceI_receiveText, iceP_msg, iceP_sender, iceP_serverName, context);
    }

    void _iceI_receiveText(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::shared_ptr<::Chat::UserPrx>&, const ::std::string&, const ::Ice::Context&);

    void receivePrivateText(const ::std::string& iceP_msg, const ::std::shared_ptr<::Chat::UserPrx>& iceP_sender, const ::Ice::Context& context = Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &Chat::UserPrx::_iceI_receivePrivateText, iceP_msg, iceP_sender, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto receivePrivateTextAsync(const ::std::string& iceP_msg, const ::std::shared_ptr<::Chat::UserPrx>& iceP_sender, const ::Ice::Context& context = Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &Chat::UserPrx::_iceI_receivePrivateText, iceP_msg, iceP_sender, context);
    }

    ::std::function<void()>
    receivePrivateTextAsync(const ::std::string& iceP_msg, const ::std::shared_ptr<::Chat::UserPrx>& iceP_sender,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(response, ex, sent, this, &Chat::UserPrx::_iceI_receivePrivateText, iceP_msg, iceP_sender, context);
    }

    void _iceI_receivePrivateText(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::shared_ptr<::Chat::UserPrx>&, const ::Ice::Context&);

    static const ::std::string& ice_staticId();

protected:

    UserPrx() = default;
    friend ::std::shared_ptr<UserPrx> IceInternal::createProxy<UserPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
};

}

namespace Ice
{

}

namespace Chat
{

using GroupServerPtr = ::std::shared_ptr<GroupServer>;
using GroupServerPrxPtr = ::std::shared_ptr<GroupServerPrx>;

using GroupServerManagerPtr = ::std::shared_ptr<GroupServerManager>;
using GroupServerManagerPrxPtr = ::std::shared_ptr<GroupServerManagerPrx>;

using UserPtr = ::std::shared_ptr<User>;
using UserPrxPtr = ::std::shared_ptr<UserPrx>;

using ChatServerPtr = ::std::shared_ptr<ChatServer>;
using ChatServerPrxPtr = ::std::shared_ptr<ChatServerPrx>;

}

#else // C++98 mapping

namespace IceProxy
{

namespace Chat
{

class GroupServer;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServer>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::GroupServer*);

class GroupServerManager;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServerManager>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::GroupServerManager*);

class User;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::User>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::User*);

class ChatServer;
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatServer>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::ChatServer*);

}

}

namespace Chat
{

class GroupServer;
::Ice::Object* upCast(::Chat::GroupServer*);
typedef ::IceInternal::Handle< ::Chat::GroupServer> GroupServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServer> GroupServerPrx;
typedef GroupServerPrx GroupServerPrxPtr;
void _icePatchObjectPtr(GroupServerPtr&, const ::Ice::ObjectPtr&);

class GroupServerManager;
::Ice::Object* upCast(::Chat::GroupServerManager*);
typedef ::IceInternal::Handle< ::Chat::GroupServerManager> GroupServerManagerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::GroupServerManager> GroupServerManagerPrx;
typedef GroupServerManagerPrx GroupServerManagerPrxPtr;
void _icePatchObjectPtr(GroupServerManagerPtr&, const ::Ice::ObjectPtr&);

class User;
::Ice::Object* upCast(::Chat::User*);
typedef ::IceInternal::Handle< ::Chat::User> UserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::User> UserPrx;
typedef UserPrx UserPrxPtr;
void _icePatchObjectPtr(UserPtr&, const ::Ice::ObjectPtr&);

class ChatServer;
::Ice::Object* upCast(::Chat::ChatServer*);
typedef ::IceInternal::Handle< ::Chat::ChatServer> ChatServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatServer> ChatServerPrx;
typedef ChatServerPrx ChatServerPrxPtr;
void _icePatchObjectPtr(ChatServerPtr&, const ::Ice::ObjectPtr&);

}

namespace Chat
{

class NameDoesNotExist : public ::Ice::UserException
{
public:

    NameDoesNotExist() {}
    virtual ~NameDoesNotExist() throw();

    virtual ::std::string ice_id() const;
    virtual NameDoesNotExist* ice_clone() const;
    virtual void ice_throw() const;

protected:

    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
};

static NameDoesNotExist _iceS_NameDoesNotExist_init;

class NameAlreadyExists : public ::Ice::UserException
{
public:

    NameAlreadyExists() {}
    virtual ~NameAlreadyExists() throw();

    virtual ::std::string ice_id() const;
    virtual NameAlreadyExists* ice_clone() const;
    virtual void ice_throw() const;

protected:

    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
};

class ServerAlreadyRegistered : public ::Ice::UserException
{
public:

    ServerAlreadyRegistered() {}
    virtual ~ServerAlreadyRegistered() throw();

    virtual ::std::string ice_id() const;
    virtual ServerAlreadyRegistered* ice_clone() const;
    virtual void ice_throw() const;

protected:

    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
};

class ServerDoesNotExist : public ::Ice::UserException
{
public:

    ServerDoesNotExist() {}
    virtual ~ServerDoesNotExist() throw();

    virtual ::std::string ice_id() const;
    virtual ServerDoesNotExist* ice_clone() const;
    virtual void ice_throw() const;

protected:

    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
};

class UserAlreadyRegistered : public ::Ice::UserException
{
public:

    UserAlreadyRegistered() {}
    virtual ~UserAlreadyRegistered() throw();

    virtual ::std::string ice_id() const;
    virtual UserAlreadyRegistered* ice_clone() const;
    virtual void ice_throw() const;

protected:

    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
};

class UserDoesNotExist : public ::Ice::UserException
{
public:

    UserDoesNotExist() {}
    virtual ~UserDoesNotExist() throw();

    virtual ::std::string ice_id() const;
    virtual UserDoesNotExist* ice_clone() const;
    virtual void ice_throw() const;

protected:

    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
};

typedef ::std::vector< ::Chat::GroupServerPrx> Groups;

typedef ::std::vector< ::Chat::UserPrx> Users;

}

namespace Chat
{

class Callback_ChatServer_LogIn_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_LogIn_Base> Callback_ChatServer_LogInPtr;

class Callback_ChatServer_getUserByName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_getUserByName_Base> Callback_ChatServer_getUserByNamePtr;

class Callback_ChatServer_GroupList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_GroupList_Base> Callback_ChatServer_GroupListPtr;

class Callback_ChatServer_getGroupServerByName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_getGroupServerByName_Base> Callback_ChatServer_getGroupServerByNamePtr;

class Callback_ChatServer_CreateGroup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_CreateGroup_Base> Callback_ChatServer_CreateGroupPtr;

class Callback_ChatServer_DeleteGroup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_DeleteGroup_Base> Callback_ChatServer_DeleteGroupPtr;

class Callback_ChatServer_registerServer_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_registerServer_Base> Callback_ChatServer_registerServerPtr;

class Callback_ChatServer_unregisterServer_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_unregisterServer_Base> Callback_ChatServer_unregisterServerPtr;

class Callback_ChatServer_LogOut_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_LogOut_Base> Callback_ChatServer_LogOutPtr;

class Callback_GroupServer_join_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_join_Base> Callback_GroupServer_joinPtr;

class Callback_GroupServer_Leave_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_Leave_Base> Callback_GroupServer_LeavePtr;

class Callback_GroupServer_SendMessage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_SendMessage_Base> Callback_GroupServer_SendMessagePtr;

class Callback_GroupServer_UserList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_UserList_Base> Callback_GroupServer_UserListPtr;

class Callback_GroupServer_Name_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServer_Name_Base> Callback_GroupServer_NamePtr;

class Callback_GroupServerManager_CreateGroup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_CreateGroup_Base> Callback_GroupServerManager_CreateGroupPtr;

class Callback_GroupServerManager_ListGroups_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_ListGroups_Base> Callback_GroupServerManager_ListGroupsPtr;

class Callback_GroupServerManager_DeleteGroup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_DeleteGroup_Base> Callback_GroupServerManager_DeleteGroupPtr;

class Callback_GroupServerManager_getGroupServerByName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_GroupServerManager_getGroupServerByName_Base> Callback_GroupServerManager_getGroupServerByNamePtr;

class Callback_User_getName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_getName_Base> Callback_User_getNamePtr;

class Callback_User_receiveText_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_receiveText_Base> Callback_User_receiveTextPtr;

class Callback_User_receivePrivateText_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_receivePrivateText_Base> Callback_User_receivePrivateTextPtr;

}

namespace IceProxy
{

namespace Chat
{

class ChatServer : public virtual ::Ice::Proxy<ChatServer, ::IceProxy::Ice::Object>
{
public:

    void LogIn(const ::Chat::UserPrx& iceP_callback, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_LogIn(_iceI_begin_LogIn(iceP_callback, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& iceP_callback, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_LogIn(iceP_callback, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& iceP_callback, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogIn(iceP_callback, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& iceP_callback, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogIn(iceP_callback, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& iceP_callback, const ::Chat::Callback_ChatServer_LogInPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogIn(iceP_callback, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_LogIn(const ::Chat::UserPrx& iceP_callback, const ::Ice::Context& context, const ::Chat::Callback_ChatServer_LogInPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogIn(iceP_callback, context, del, cookie);
    }

    void end_LogIn(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_LogIn(const ::Chat::UserPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Chat::UserPrx getUserByName(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getUserByName(_iceI_begin_getUserByName(iceP_name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getUserByName(iceP_name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& iceP_name, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getUserByName(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getUserByName(iceP_name, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& iceP_name, const ::Chat::Callback_ChatServer_getUserByNamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getUserByName(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getUserByName(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Chat::Callback_ChatServer_getUserByNamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getUserByName(iceP_name, context, del, cookie);
    }

    ::Chat::UserPrx end_getUserByName(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getUserByName(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Chat::Groups GroupList(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GroupList(_iceI_begin_GroupList(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GroupList(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GroupList(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GroupList(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Chat::Callback_ChatServer_GroupListPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GroupList(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_GroupList(const ::Ice::Context& context, const ::Chat::Callback_ChatServer_GroupListPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GroupList(context, del, cookie);
    }

    ::Chat::Groups end_GroupList(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GroupList(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Chat::GroupServerPrx getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getGroupServerByName(_iceI_begin_getGroupServerByName(iceP_name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Chat::Callback_ChatServer_getGroupServerByNamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Chat::Callback_ChatServer_getGroupServerByNamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, context, del, cookie);
    }

    ::Chat::GroupServerPrx end_getGroupServerByName(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getGroupServerByName(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_CreateGroup(_iceI_begin_CreateGroup(iceP_name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_CreateGroup(iceP_name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CreateGroup(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CreateGroup(iceP_name, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Chat::Callback_ChatServer_CreateGroupPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CreateGroup(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Chat::Callback_ChatServer_CreateGroupPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CreateGroup(iceP_name, context, del, cookie);
    }

    void end_CreateGroup(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_CreateGroup(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_DeleteGroup(_iceI_begin_DeleteGroup(iceP_name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_DeleteGroup(iceP_name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DeleteGroup(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DeleteGroup(iceP_name, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Chat::Callback_ChatServer_DeleteGroupPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DeleteGroup(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Chat::Callback_ChatServer_DeleteGroupPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DeleteGroup(iceP_name, context, del, cookie);
    }

    void end_DeleteGroup(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_DeleteGroup(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void registerServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_registerServer(_iceI_begin_registerServer(iceP_serverManager, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerServer(iceP_serverManager, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerServer(iceP_serverManager, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerServer(iceP_serverManager, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Chat::Callback_ChatServer_registerServerPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerServer(iceP_serverManager, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::Context& context, const ::Chat::Callback_ChatServer_registerServerPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerServer(iceP_serverManager, context, del, cookie);
    }

    void end_registerServer(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unregisterServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unregisterServer(_iceI_begin_unregisterServer(iceP_serverManager, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unregisterServer(iceP_serverManager, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterServer(iceP_serverManager, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterServer(iceP_serverManager, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Chat::Callback_ChatServer_unregisterServerPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterServer(iceP_serverManager, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterServer(const ::Chat::GroupServerManagerPrx& iceP_serverManager, const ::Ice::Context& context, const ::Chat::Callback_ChatServer_unregisterServerPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterServer(iceP_serverManager, context, del, cookie);
    }

    void end_unregisterServer(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unregisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void LogOut(const ::Chat::UserPrx& iceP_callback, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_LogOut(_iceI_begin_LogOut(iceP_callback, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_LogOut(const ::Chat::UserPrx& iceP_callback, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_LogOut(iceP_callback, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_LogOut(const ::Chat::UserPrx& iceP_callback, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogOut(iceP_callback, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_LogOut(const ::Chat::UserPrx& iceP_callback, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogOut(iceP_callback, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_LogOut(const ::Chat::UserPrx& iceP_callback, const ::Chat::Callback_ChatServer_LogOutPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogOut(iceP_callback, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_LogOut(const ::Chat::UserPrx& iceP_callback, const ::Ice::Context& context, const ::Chat::Callback_ChatServer_LogOutPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_LogOut(iceP_callback, context, del, cookie);
    }

    void end_LogOut(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_LogOut(const ::Chat::UserPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class GroupServer : public virtual ::Ice::Proxy<GroupServer, ::IceProxy::Ice::Object>
{
public:

    void join(const ::Chat::UserPrx& iceP_who, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_join(_iceI_begin_join(iceP_who, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& iceP_who, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_join(iceP_who, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& iceP_who, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_join(iceP_who, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& iceP_who, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_join(iceP_who, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& iceP_who, const ::Chat::Callback_GroupServer_joinPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_join(iceP_who, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_join(const ::Chat::UserPrx& iceP_who, const ::Ice::Context& context, const ::Chat::Callback_GroupServer_joinPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_join(iceP_who, context, del, cookie);
    }

    void end_join(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_join(const ::Chat::UserPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void Leave(const ::Chat::UserPrx& iceP_who, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_Leave(_iceI_begin_Leave(iceP_who, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& iceP_who, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_Leave(iceP_who, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& iceP_who, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Leave(iceP_who, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& iceP_who, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Leave(iceP_who, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& iceP_who, const ::Chat::Callback_GroupServer_LeavePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Leave(iceP_who, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_Leave(const ::Chat::UserPrx& iceP_who, const ::Ice::Context& context, const ::Chat::Callback_GroupServer_LeavePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Leave(iceP_who, context, del, cookie);
    }

    void end_Leave(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_Leave(const ::Chat::UserPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendMessage(const ::std::string& iceP_message, const ::Chat::UserPrx& iceP_sender, const ::Chat::GroupServerPrx& iceP_gs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendMessage(_iceI_begin_SendMessage(iceP_message, iceP_sender, iceP_gs, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& iceP_message, const ::Chat::UserPrx& iceP_sender, const ::Chat::GroupServerPrx& iceP_gs, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendMessage(iceP_message, iceP_sender, iceP_gs, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& iceP_message, const ::Chat::UserPrx& iceP_sender, const ::Chat::GroupServerPrx& iceP_gs, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendMessage(iceP_message, iceP_sender, iceP_gs, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& iceP_message, const ::Chat::UserPrx& iceP_sender, const ::Chat::GroupServerPrx& iceP_gs, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendMessage(iceP_message, iceP_sender, iceP_gs, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& iceP_message, const ::Chat::UserPrx& iceP_sender, const ::Chat::GroupServerPrx& iceP_gs, const ::Chat::Callback_GroupServer_SendMessagePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendMessage(iceP_message, iceP_sender, iceP_gs, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendMessage(const ::std::string& iceP_message, const ::Chat::UserPrx& iceP_sender, const ::Chat::GroupServerPrx& iceP_gs, const ::Ice::Context& context, const ::Chat::Callback_GroupServer_SendMessagePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendMessage(iceP_message, iceP_sender, iceP_gs, context, del, cookie);
    }

    void end_SendMessage(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Chat::GroupServerPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Chat::Users UserList(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_UserList(_iceI_begin_UserList(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UserList(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UserList(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UserList(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Chat::Callback_GroupServer_UserListPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UserList(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_UserList(const ::Ice::Context& context, const ::Chat::Callback_GroupServer_UserListPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UserList(context, del, cookie);
    }

    ::Chat::Users end_UserList(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UserList(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string Name(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_Name(_iceI_begin_Name(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_Name(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Name(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Name(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Chat::Callback_GroupServer_NamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Name(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_Name(const ::Ice::Context& context, const ::Chat::Callback_GroupServer_NamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Name(context, del, cookie);
    }

    ::std::string end_Name(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_Name(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class GroupServerManager : public virtual ::Ice::Proxy<GroupServerManager, ::IceProxy::Ice::Object>
{
public:

    ::Chat::GroupServerPrx CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_CreateGroup(_iceI_begin_CreateGroup(iceP_name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_CreateGroup(iceP_name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CreateGroup(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CreateGroup(iceP_name, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Chat::Callback_GroupServerManager_CreateGroupPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CreateGroup(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_CreateGroup(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Chat::Callback_GroupServerManager_CreateGroupPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_CreateGroup(iceP_name, context, del, cookie);
    }

    ::Chat::GroupServerPrx end_CreateGroup(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_CreateGroup(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Chat::Groups ListGroups(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ListGroups(_iceI_begin_ListGroups(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ListGroups(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ListGroups(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ListGroups(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Chat::Callback_GroupServerManager_ListGroupsPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ListGroups(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_ListGroups(const ::Ice::Context& context, const ::Chat::Callback_GroupServerManager_ListGroupsPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ListGroups(context, del, cookie);
    }

    ::Chat::Groups end_ListGroups(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ListGroups(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_DeleteGroup(_iceI_begin_DeleteGroup(iceP_name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_DeleteGroup(iceP_name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DeleteGroup(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DeleteGroup(iceP_name, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Chat::Callback_GroupServerManager_DeleteGroupPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DeleteGroup(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_DeleteGroup(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Chat::Callback_GroupServerManager_DeleteGroupPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DeleteGroup(iceP_name, context, del, cookie);
    }

    void end_DeleteGroup(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_DeleteGroup(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Chat::GroupServerPrx getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getGroupServerByName(_iceI_begin_getGroupServerByName(iceP_name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Chat::Callback_GroupServerManager_getGroupServerByNamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getGroupServerByName(const ::std::string& iceP_name, const ::Ice::Context& context, const ::Chat::Callback_GroupServerManager_getGroupServerByNamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getGroupServerByName(iceP_name, context, del, cookie);
    }

    ::Chat::GroupServerPrx end_getGroupServerByName(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getGroupServerByName(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

class User : public virtual ::Ice::Proxy<User, ::IceProxy::Ice::Object>
{
public:

    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getName(_iceI_begin_getName(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getName(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Chat::Callback_User_getNamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::Chat::Callback_User_getNamePtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, del, cookie);
    }

    ::std::string end_getName(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getName(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void receiveText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::std::string& iceP_serverName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_receiveText(_iceI_begin_receiveText(iceP_msg, iceP_sender, iceP_serverName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::std::string& iceP_serverName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_receiveText(iceP_msg, iceP_sender, iceP_serverName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::std::string& iceP_serverName, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_receiveText(iceP_msg, iceP_sender, iceP_serverName, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::std::string& iceP_serverName, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_receiveText(iceP_msg, iceP_sender, iceP_serverName, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::std::string& iceP_serverName, const ::Chat::Callback_User_receiveTextPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_receiveText(iceP_msg, iceP_sender, iceP_serverName, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_receiveText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::std::string& iceP_serverName, const ::Ice::Context& context, const ::Chat::Callback_User_receiveTextPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_receiveText(iceP_msg, iceP_sender, iceP_serverName, context, del, cookie);
    }

    void end_receiveText(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_receiveText(const ::std::string&, const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void receivePrivateText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_receivePrivateText(_iceI_begin_receivePrivateText(iceP_msg, iceP_sender, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_receivePrivateText(iceP_msg, iceP_sender, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_receivePrivateText(iceP_msg, iceP_sender, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::Ice::Context& context, const ::Ice::CallbackPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_receivePrivateText(iceP_msg, iceP_sender, context, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::Chat::Callback_User_receivePrivateTextPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_receivePrivateText(iceP_msg, iceP_sender, ::Ice::noExplicitContext, del, cookie);
    }

    ::Ice::AsyncResultPtr begin_receivePrivateText(const ::std::string& iceP_msg, const ::Chat::UserPrx& iceP_sender, const ::Ice::Context& context, const ::Chat::Callback_User_receivePrivateTextPtr& del, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_receivePrivateText(iceP_msg, iceP_sender, context, del, cookie);
    }

    void end_receivePrivateText(const ::Ice::AsyncResultPtr&);

private:

    ::Ice::AsyncResultPtr _iceI_begin_receivePrivateText(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    static const ::std::string& ice_staticId();

protected:

    virtual ::IceProxy::Ice::Object* _newInstance() const;
};

}

}

namespace Chat
{

class ChatServer : public virtual ::Ice::Object
{
public:

    typedef ChatServerPrx ProxyType;
    typedef ChatServerPtr PointerType;

    virtual ~ChatServer();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual void LogIn(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_LogIn(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::UserPrx getUserByName(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getUserByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Groups GroupList(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_GroupList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::GroupServerPrx getGroupServerByName(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getGroupServerByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void CreateGroup(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_CreateGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void DeleteGroup(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_DeleteGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void registerServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_registerServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void unregisterServer(const ::Chat::GroupServerManagerPrx&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_unregisterServer(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void LogOut(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_LogOut(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const ChatServer& lhs, const ChatServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ChatServer& lhs, const ChatServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class GroupServer : public virtual ::Ice::Object
{
public:

    typedef GroupServerPrx ProxyType;
    typedef GroupServerPtr PointerType;

    virtual ~GroupServer();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual void join(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_join(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void Leave(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_Leave(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void SendMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Chat::GroupServerPrx&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_SendMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Users UserList(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_UserList(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string Name(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_Name(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const GroupServer& lhs, const GroupServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const GroupServer& lhs, const GroupServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class GroupServerManager : public virtual ::Ice::Object
{
public:

    typedef GroupServerManagerPrx ProxyType;
    typedef GroupServerManagerPtr PointerType;

    virtual ~GroupServerManager();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual ::Chat::GroupServerPrx CreateGroup(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_CreateGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::Groups ListGroups(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_ListGroups(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void DeleteGroup(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_DeleteGroup(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::GroupServerPrx getGroupServerByName(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getGroupServerByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const GroupServerManager& lhs, const GroupServerManager& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const GroupServerManager& lhs, const GroupServerManager& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

class User : public virtual ::Ice::Object
{
public:

    typedef UserPrx ProxyType;
    typedef UserPtr PointerType;

    virtual ~User();

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::emptyCurrent) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::emptyCurrent) const;

    static const ::std::string& ice_staticId();

    virtual ::std::string getName(const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void receiveText(const ::std::string&, const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_receiveText(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void receivePrivateText(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::emptyCurrent) = 0;
    bool _iceD_receivePrivateText(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:

    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
};

inline bool operator==(const User& lhs, const User& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const User& lhs, const User& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}

}

namespace Ice
{

template<>
struct StreamableTraits< ::Chat::NameDoesNotExist>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::NameAlreadyExists>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::ServerAlreadyRegistered>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::ServerDoesNotExist>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::UserAlreadyRegistered>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::UserDoesNotExist>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Chat
{

template<class T>
class CallbackNC_ChatServer_LogIn : public Callback_ChatServer_LogIn_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_LogIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_LogIn(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogIn<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_LogIn : public Callback_ChatServer_LogIn_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_LogIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_LogIn(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogInPtr
newCallback_ChatServer_LogIn(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogIn<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_getUserByName : public Callback_ChatServer_getUserByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::UserPrx&);

    CallbackNC_ChatServer_getUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        ::Chat::UserPrx ret;
        try
        {
            ret = proxy->end_getUserByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_ChatServer_getUserByNamePtr
newCallback_ChatServer_getUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getUserByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_getUserByNamePtr
newCallback_ChatServer_getUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getUserByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_getUserByName : public Callback_ChatServer_getUserByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::UserPrx&, const CT&);

    Callback_ChatServer_getUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        ::Chat::UserPrx ret;
        try
        {
            ret = proxy->end_getUserByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_getUserByNamePtr
newCallback_ChatServer_getUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_getUserByNamePtr
newCallback_ChatServer_getUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_GroupList : public Callback_ChatServer_GroupList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::Groups&);

    CallbackNC_ChatServer_GroupList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        ::Chat::Groups ret;
        try
        {
            ret = proxy->end_GroupList(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GroupList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(T* instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_GroupList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_GroupList : public Callback_ChatServer_GroupList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::Groups&, const CT&);

    Callback_ChatServer_GroupList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        ::Chat::Groups ret;
        try
        {
            ret = proxy->end_GroupList(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GroupList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_GroupListPtr
newCallback_ChatServer_GroupList(T* instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_GroupList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_getGroupServerByName : public Callback_ChatServer_getGroupServerByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&);

    CallbackNC_ChatServer_getGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        ::Chat::GroupServerPrx ret;
        try
        {
            ret = proxy->end_getGroupServerByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_ChatServer_getGroupServerByNamePtr
newCallback_ChatServer_getGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_getGroupServerByNamePtr
newCallback_ChatServer_getGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_getGroupServerByName : public Callback_ChatServer_getGroupServerByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&, const CT&);

    Callback_ChatServer_getGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        ::Chat::GroupServerPrx ret;
        try
        {
            ret = proxy->end_getGroupServerByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_getGroupServerByNamePtr
newCallback_ChatServer_getGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_getGroupServerByNamePtr
newCallback_ChatServer_getGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_CreateGroup : public Callback_ChatServer_CreateGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_CreateGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_CreateGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_CreateGroup : public Callback_ChatServer_CreateGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_CreateGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_CreateGroupPtr
newCallback_ChatServer_CreateGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_CreateGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_DeleteGroup : public Callback_ChatServer_DeleteGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_DeleteGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_DeleteGroup : public Callback_ChatServer_DeleteGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_DeleteGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_DeleteGroupPtr
newCallback_ChatServer_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_registerServer : public Callback_ChatServer_registerServer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_registerServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_registerServer(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerServer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerServer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_registerServer : public Callback_ChatServer_registerServer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_registerServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_registerServer(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerServerPtr
newCallback_ChatServer_registerServer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_unregisterServer : public Callback_ChatServer_unregisterServer_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_unregisterServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unregisterServer(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_unregisterServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_unregisterServer<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_unregisterServer<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_unregisterServer<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_unregisterServer : public Callback_ChatServer_unregisterServer_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_unregisterServer(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::ChatServerPrx proxy = ::Chat::ChatServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unregisterServer(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_unregisterServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_unregisterServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_unregisterServer<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_unregisterServerPtr
newCallback_ChatServer_unregisterServer(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_unregisterServer<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_LogOut : public Callback_ChatServer_LogOut_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_LogOut(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ChatServer_LogOutPtr
newCallback_ChatServer_LogOut(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogOut<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_LogOutPtr
newCallback_ChatServer_LogOut(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogOut<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_LogOutPtr
newCallback_ChatServer_LogOut(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogOut<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_LogOutPtr
newCallback_ChatServer_LogOut(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_LogOut<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_LogOut : public Callback_ChatServer_LogOut_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_LogOut(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ChatServer_LogOutPtr
newCallback_ChatServer_LogOut(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogOut<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogOutPtr
newCallback_ChatServer_LogOut(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogOut<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogOutPtr
newCallback_ChatServer_LogOut(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogOut<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_LogOutPtr
newCallback_ChatServer_LogOut(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_LogOut<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_join : public Callback_GroupServer_join_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServer_join(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_join(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_join<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_join<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_join<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_join<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_join : public Callback_GroupServer_join_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServer_join(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_join(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_join<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_join<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_join<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_joinPtr
newCallback_GroupServer_join(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_join<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_Leave : public Callback_GroupServer_Leave_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServer_Leave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_Leave(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Leave<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_Leave : public Callback_GroupServer_Leave_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServer_Leave(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_Leave(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_LeavePtr
newCallback_GroupServer_Leave(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Leave<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_SendMessage : public Callback_GroupServer_SendMessage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServer_SendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SendMessage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_SendMessage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_SendMessage : public Callback_GroupServer_SendMessage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServer_SendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SendMessage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_SendMessagePtr
newCallback_GroupServer_SendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_SendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_UserList : public Callback_GroupServer_UserList_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::Users&);

    CallbackNC_GroupServer_UserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        ::Chat::Users ret;
        try
        {
            ret = proxy->end_UserList(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Users&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_UserList<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(T* instance, void (T::*cb)(const ::Chat::Users&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_UserList<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_UserList : public Callback_GroupServer_UserList_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::Users&, const CT&);

    Callback_GroupServer_UserList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        ::Chat::Users ret;
        try
        {
            ret = proxy->end_UserList(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Users&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_UserList<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_UserListPtr
newCallback_GroupServer_UserList(T* instance, void (T::*cb)(const ::Chat::Users&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_UserList<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServer_Name : public Callback_GroupServer_Name_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_GroupServer_Name(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_Name(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Name<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServer_Name<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServer_Name : public Callback_GroupServer_Name_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_GroupServer_Name(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerPrx proxy = ::Chat::GroupServerPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_Name(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Name<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServer_NamePtr
newCallback_GroupServer_Name(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServer_Name<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_CreateGroup : public Callback_GroupServerManager_CreateGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&);

    CallbackNC_GroupServerManager_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerManagerPrx proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(result->getProxy());
        ::Chat::GroupServerPrx ret;
        try
        {
            ret = proxy->end_CreateGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_CreateGroup<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_CreateGroup : public Callback_GroupServerManager_CreateGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&, const CT&);

    Callback_GroupServerManager_CreateGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerManagerPrx proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(result->getProxy());
        ::Chat::GroupServerPrx ret;
        try
        {
            ret = proxy->end_CreateGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_CreateGroupPtr
newCallback_GroupServerManager_CreateGroup(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_CreateGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_ListGroups : public Callback_GroupServerManager_ListGroups_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::Groups&);

    CallbackNC_GroupServerManager_ListGroups(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerManagerPrx proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(result->getProxy());
        ::Chat::Groups ret;
        try
        {
            ret = proxy->end_ListGroups(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_ListGroups<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(T* instance, void (T::*cb)(const ::Chat::Groups&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_ListGroups<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_ListGroups : public Callback_GroupServerManager_ListGroups_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::Groups&, const CT&);

    Callback_GroupServerManager_ListGroups(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerManagerPrx proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(result->getProxy());
        ::Chat::Groups ret;
        try
        {
            ret = proxy->end_ListGroups(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_ListGroups<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_ListGroupsPtr
newCallback_GroupServerManager_ListGroups(T* instance, void (T::*cb)(const ::Chat::Groups&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_ListGroups<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_DeleteGroup : public Callback_GroupServerManager_DeleteGroup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_GroupServerManager_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerManagerPrx proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_DeleteGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }

private:

    Response _response;
};

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_DeleteGroup<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_DeleteGroup : public Callback_GroupServerManager_DeleteGroup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_GroupServerManager_DeleteGroup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerManagerPrx proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_DeleteGroup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_DeleteGroupPtr
newCallback_GroupServerManager_DeleteGroup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_DeleteGroup<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_GroupServerManager_getGroupServerByName : public Callback_GroupServerManager_getGroupServerByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&);

    CallbackNC_GroupServerManager_getGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerManagerPrx proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(result->getProxy());
        ::Chat::GroupServerPrx ret;
        try
        {
            ret = proxy->end_getGroupServerByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_GroupServerManager_getGroupServerByNamePtr
newCallback_GroupServerManager_getGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_getGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_GroupServerManager_getGroupServerByNamePtr
newCallback_GroupServerManager_getGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_GroupServerManager_getGroupServerByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_GroupServerManager_getGroupServerByName : public Callback_GroupServerManager_getGroupServerByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::GroupServerPrx&, const CT&);

    Callback_GroupServerManager_getGroupServerByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::GroupServerManagerPrx proxy = ::Chat::GroupServerManagerPrx::uncheckedCast(result->getProxy());
        ::Chat::GroupServerPrx ret;
        try
        {
            ret = proxy->end_getGroupServerByName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_GroupServerManager_getGroupServerByNamePtr
newCallback_GroupServerManager_getGroupServerByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_getGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_GroupServerManager_getGroupServerByNamePtr
newCallback_GroupServerManager_getGroupServerByName(T* instance, void (T::*cb)(const ::Chat::GroupServerPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_GroupServerManager_getGroupServerByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_User_getName : public Callback_User_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_User_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::UserPrx proxy = ::Chat::UserPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }

private:

    Response _response;
};

template<class T> Callback_User_getNamePtr
newCallback_User_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_getNamePtr
newCallback_User_getName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_getName : public Callback_User_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_User_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ::Chat::UserPrx proxy = ::Chat::UserPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }

private:

    Response _response;
};

template<class T, typename CT> Callback_User_getNamePtr
newCallback_User_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_getNamePtr
newCallback_User_getName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_User_receiveText : public Callback_User_receiveText_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_receiveText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_receiveTextPtr
newCallback_User_receiveText(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receiveText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_receiveTextPtr
newCallback_User_receiveText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receiveText<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_receiveTextPtr
newCallback_User_receiveText(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receiveText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_receiveTextPtr
newCallback_User_receiveText(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receiveText<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_receiveText : public Callback_User_receiveText_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_receiveText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_receiveTextPtr
newCallback_User_receiveText(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receiveText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_receiveTextPtr
newCallback_User_receiveText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receiveText<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_receiveTextPtr
newCallback_User_receiveText(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receiveText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_receiveTextPtr
newCallback_User_receiveText(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receiveText<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_receivePrivateText : public Callback_User_receivePrivateText_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_receivePrivateText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receivePrivateText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receivePrivateText<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receivePrivateText<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_receivePrivateText<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_receivePrivateText : public Callback_User_receivePrivateText_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_receivePrivateText(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receivePrivateText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receivePrivateText<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receivePrivateText<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_receivePrivateTextPtr
newCallback_User_receivePrivateText(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_receivePrivateText<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
